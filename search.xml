<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[10张前端基础知识（超全）思维导图]]></title>
    <url>%2F2018%2F03%2F13%2F%E8%BD%AC%E8%BD%BD%E5%87%A0%E5%BC%A0%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E8%B6%85%E5%85%A8%EF%BC%89%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在Aaron个人技术博客看到十张前端思维导图，涉及到的基础知识比较全面，温故知新的我就当个笔记整理了下来。 javascript数据类型 javascript数组 javascript运算符 javascript正则表达式 javascript字符串函数 window对象 DOM基本操作 javascript变量 javascript函数基础 javascript流程控制]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联动菜单LinkageView]]></title>
    <url>%2F2017%2F09%2F10%2F%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95LinkageView%2F</url>
    <content type="text"><![CDATA[LinkageView联动视图，有网易云音乐效果及网易新闻效果 GitHub地址 Support 支持snpkit框架 两种页面切换效果 支持修改各种颜色 支持自定义组件内容 支持两种菜单多屏及单屏 支持滑动条动态自适应标题长度 组头和内容分开编码，易于扩展，自己也会持续更新 Usage12//默认效果：一屏菜单 可以省略参数headerView = LVHeaderView.init(styleMore: false) 12//多屏菜单效果headerView = LVHeaderView.init(styleMore: true) 12//放大缩小切换效果效果 默认styleLine为 true 即滚动条效果headerView = LVHeaderView.init(styleMore: true, styleLine: false) 具体使用1234567891011121314151617181920let arr = ["个性推荐", "歌单", "主播平台", "排行榜"]headerView = LVHeaderView.init(styleMore: false)view.addSubview(headerView)headerView.delegate = selfheaderView.dataAry = arrheaderView.snp.makeConstraints &#123; (make) inmake.top.equalTo(64)make.left.right.equalToSuperview()make.height.equalTo(40)&#125;contentView = LVContentView()view.addSubview(contentView)self.contentView.dataArr = arrcontentView.contentDelegate = selfcontentView.snp.makeConstraints &#123; (make) inmake.top.equalTo(headerView.snp.bottom)make.bottom.right.left.equalToSuperview()&#125; 代理方法12345678910111213//头组件代理方法 实现标题点击的事件传递 使得内容组件响应滚动extension ViewController: LVHeaderViewDelegate &#123;func selectdLVHeaderView(view: LVHeaderView, selectedIndex: Int) &#123;let indexPath = IndexPath(item: selectedIndex, section: 0)contentView.scrollToItem(at: indexPath, at: .centeredHorizontally, animated: false)&#125;&#125;//内容组件代理方法 实现与组头的联动效果extension ViewController: LVcontentDelegate &#123;func contentView(_ contentView: LVContentView,nowPage: Int, fromIndex: Int, toIndex: Int, scale: CGFloat) &#123;headerView.scrollTodo(nowPage: nowPage, fromIndex: fromIndex, toIndex: toIndex, scale: scale)&#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下正确安装运行VUE]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8B%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8CVUE%2F</url>
    <content type="text"><![CDATA[因为开发用的Mac系统，所以网上很多vue.js组件化开发环境搭建教程都不完全适用，多次踩坑总结了一下正确姿势，当做笔记，望指正。如果你只是简单的想了解使用，请移步 官方教程 。 以下操作都在Mac自带终端操作: 首先安装包管理homebrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 node.js两种方式安装：node下载安装命令安装（推荐） 获取nodejs模块安装目录访问权限如果不获取权限，是安装不成功的。sudo chmod -R 777 /usr/local/lib/node_modules/ 更换淘宝镜像（cnpm）不换的话速度慢得要死，大家时间都很宝贵的。npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 webpack 模块打包器cnpm install webpack -g 安装 vue.cli 工具sudo cnpm install -g vue-cli 本机创建一个文件夹放工程用，并cd到该目录请不要直接复制粘贴cd /Users/qingqing/Desktop/技术相关/VUE 终于到了创建 vue.js 工程my-project是你要创建的工程名字，可以随意写但是不能有中文。vue init webpack my-project之后会出现很多设置，我这里都选的yes 当然也可以选择no，只是一些测试工具，code工具等。 安装项目依赖cd 到创建的工程目录下 我这里是 cd my-projectcnpm install 安装 vue 路由模块vue-router和网络请求模块vue-resourcecnpm install vue-router vue-resource --save 启动项目npm run dev 至此就完成了，开心愉快的创造吧！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上shell常用命令]]></title>
    <url>%2F2017%2F03%2F09%2FMac%E4%B8%8Ashell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[启动tomcat123456// 进入目录cd /Library/Tomcat/bin// 开启sudo sh startup.sh// 结束sudo sh shutdown.sh 隐藏文件的显示与否显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true隐藏隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false运行命令后还需要ption+command+esc重启 访达 开启信任任何来源有时候从第三方网站下载的应用，安装显示损坏或无法安装，其实需要选择 任意来源可以安装应用，而mac默认隐藏这个选择的，所以需要sudo spctl --master-disable开启。然后你就可以从系统偏好设置-&gt;安全性与隐私-&gt;通用-&gt;允许从以下位置下载的应用 选择了。 查看本机ipifconfig 会出现不少信息，仔细找找就看到了 运行vue项目cd到目录下1234# 开发环境运行npm run dev# webpack打包项目npm run build Hexo相关12345678910npm install hexo -g # 安装npm update hexo -g # 升级hexo init # 初始化hexo p == hexo publish # 草稿hexo d == hexo deploy # 部署hexo s --debug # 本地4000运行hexo g == hexo generate # 生成hexo new page &quot;pageName&quot; # 新建页面hexo s == hexo server # 启动服务预览hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章 退出运行状态control + c]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>tamcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage原理和缓存机制]]></title>
    <url>%2F2016%2F05%2F11%2FSDWebImage%E5%8E%9F%E7%90%86%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[这篇文章将主要介绍SDWebImage针对于获取网络图片的原理和缓存机制，当然我只是用文字去介绍大体的一个流程，学无止境，需要更详细东西的朋友自行百度深入了解。 先介绍一下两个重要的功能1. 独立的异步图像下载1- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock; 上面函数用来建立一个SDWebImageDownLoader的实例。利用下载进度的回调和下载完成的回调，可以在回调完成进度条相关的操作和显示图片相关的操作。 2. 独立的异步图像缓存(存、取、删的详细代码介绍附在最后)1SDImageCache *imageCache = [SDImageCache sharedImageCache]; SDImageCache类提供一个管理缓存的单例类。查找和缓存图片时简单理解为以URL作为key。(先查找图片缓存，如果缓存不存在该图片，再查找沙盒；查找沙盒时，以URL组合成文件路径进行的MD5值作为key).查找图片：1UIImage *cacheImage = [imageCache mageFromKey:myCacheKey]; 缓存图片：1[imageCache storeImage:myImage forKey:myCacheKey]; 默认情况下，图片是被存储到内存缓存和磁盘缓存中的。如果仅仅是想缓存到内存中，可以用下面方法：1storeImage: forKey: toDisk: 第三个参数传NO即可。 主要用到的对象： UIImageView(WebCache)入口封装，实现读取图片完成后的回调。 SDWebImagemanager对图片进行管理的中转站，记录那些图片正在读取。向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader）。实现SDImageCache和SDWebImageDownLoader的回调。 SDImageCache,根据URL作为key，对图片进行存储和读取（存在内存（以URL作为key）和存在硬盘两种（以URL组合成文件路径进行的MD5值作为key））。实现图片和内存清理工作。 SDWebImage加载图片的流程 入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage显示，然后 SDWebImageManager根据 URL 开始处理图片。 进入SDWebImageManager 类中downloadWithURL:delegate:options:userInfo:，交给SDImageCache从缓存查找图片是否已经下载queryDiskCacheForKey:delegate:userInfo:. 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate回调 imageCache:didFindImage:forKey:userInfo:到SDWebImageManager。 SDWebImageManagerDelegate 回调webImageManager:didFinishWithImage: 到 UIImageView+WebCache,等前端展示图片。 如果内存缓存中没有，生成 ｀NSURLSession ｀添加到队列，开始从沙盒查找图片是否已经缓存。 根据 URL组合成的Key在沙河缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。 如果上一操作从沙盒读取到了图片，将图片添加到内存缓存中（如果空闲内存过小， 会先清空内存缓存）。SDImageCacheDelegate回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。 如果从沙盒目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片， 回调 imageCache:didNotFindImageForKey:userInfo:。 共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。 图片下载由 NSURLConnection来做，实现相关 delegate来判断图片下载中、下载完成和下载失败。 connection:didReceiveData:中利用 ImageIO做了按图片下载进度加载效果。 connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder做图片解码处理。 图片解码处理在一个NSOperationQueue完成，不会拖慢主线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 在主线程notifyDelegateOnMainThreadWithInfo:宣告解码完成imageDecoder:didFinishDecodingImage:userInfo:回调给SDWebImageDownloader。 imageDownloader:didFinishWithImage:回调给 SDWebImageManager告知图片 下载完成。 通知所有的downloadDelegates下载完成，回调给需要的地方展示图片。 将图片保存到 SDImageCache中，内存缓存和沙盒缓存同时保存。写文件到沙盒也在以单独NSOperation完成，避免拖慢主线程。 SDImageCache在初始化的时候会注册一些消息通知，在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候清理过期图片。 存:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677-(void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;if (!image || !key) &#123;return;&#125;// if memory cache is enabledif (self.shouldCacheImagesInMemory) &#123;NSUInteger cost = SDCacheCostForImage(image);[self.memCache setObject:image forKey:key cost:cost];&#125;if (toDisk) &#123;dispatch_async(self.ioQueue, ^&#123;NSData *data = imageData;// 如果image存在，但是需要重新计算(recalculate)或者data为空// 那就要根据image重新生成新的data// 不过要是连image也为空的话，那就别存了if (image &amp;&amp; (recalculate || !data)) &#123;#if TARGET_OS_IPHONE// 我们需要判断image是PNG还是JPEG// PNG的图片很容易检测出来，因为它们有一个特定的标示 (http://www.w3.org/TR/PNG-Structure.html)// PNG图片的前8个字节不许符合下面这些值(十进制表示)// 137 80 78 71 13 10 26 10// 如果imageData为空l (举个例子，比如image在下载后需要transform，那么就imageData就会为空)// 并且image有一个alpha通道, 我们将该image看做PNG以避免透明度(alpha)的丢失（因为JPEG没有透明色）int alphaInfo = CGImageGetAlphaInfo(image.CGImage);// 获取image中的透明信息// 该image中确实有透明信息，就认为image为PNGBOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||alphaInfo == kCGImageAlphaNoneSkipFirst ||alphaInfo == kCGImageAlphaNoneSkipLast);BOOL imageIsPng = hasAlpha;// 但是如果我们已经有了imageData，我们就可以直接根据data中前几个字节判断是不是PNGif ([imageData length] &gt;= [kPNGSignatureData length]) &#123;// ImageDataHasPNGPreffix就是为了判断imageData前8个字节是不是符合PNG标志imageIsPng = ImageDataHasPNGPreffix(imageData);&#125;// 如果image是PNG格式，就是用UIImagePNGRepresentation将其转化为NSData，否则按照JPEG格式转化，并且压缩质量为1，即无压缩if (imageIsPng) &#123;data = UIImagePNGRepresentation(image);&#125;else &#123;data = UIImageJPEGRepresentation(image, (CGFloat)1.0);&#125;#else// 当然，如果不是在iPhone平台上，就使用下面这个方法。不过不在我们研究范围之内data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];#endif&#125;// 获取到需要存储的data后，下面就要用fileManager进行存储了if (data) &#123;// 首先判断disk cache的文件路径是否存在，不存在的话就创建一个// disk cache的文件路径是存储在_diskCachePath中的if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;[_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];&#125;// 根据image的key(一般情况下理解为image的url)组合成最终的文件路径// 上面那个生成的文件路径只是一个文件目录，就跟/cache/images/img1.png和cache/images/的区别一样NSString *cachePathForKey = [self defaultCachePathForKey:key];// 这个url可不是网络端的url，而是file在系统路径下的url// 比如/foo/bar/baz --------&gt; file:///foo/bar/bazNSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];// 根据存储的路径(cachePathForKey)和存储的数据(data)将其存放到iOS的文件系统[_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];// disable iCloud backupif (self.shouldDisableiCloud) &#123;[fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];&#125;&#125;&#125;);&#125;&#125; 取：内存缓存使用NSCache的objectForKey取数据：123- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;return [self.memCache objectForKey:key];&#125; 磁盘取数据 不断用 dataWithContentsOfFile来试数据是否在key对应的路径中1234567891011121314151617- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;// First check the in-memory cache...UIImage *image = [self imageFromMemoryCacheForKey:key];if (image) &#123;return image;&#125;// Second check the disk cache...UIImage *diskImage = [self diskImageForKey:key];if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;NSUInteger cost = SDCacheCostForImage(diskImage);[self.memCache setObject:diskImage forKey:key cost:cost];&#125;return diskImage;&#125; 删： removeImageForKeyfromDisk:withCompletion: // 异步地将image从缓存(内存缓存以及可选的磁盘缓存)中移除 clearMemory // 清楚内存缓存上的所有image clearDisk // 清除磁盘缓存上的所有image cleanDisk // 清除磁盘缓存上过期的image看其中最长的一个： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 实现了一个简单的缓存清除策略：清除修改时间最早的file- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;dispatch_async(self.ioQueue, ^&#123;// 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的// 一个是记录遍历的文件目录，一个是记录遍历需要预先获取文件的哪些属性NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];// 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL// 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到// NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURLincludingPropertiesForKeys:resourceKeysoptions:NSDirectoryEnumerationSkipsHiddenFileserrorHandler:NULL];// 获取文件的过期时间，SDWebImage中默认是一个星期// 不过这里虽然称*expirationDate为过期时间，但是实质上并不是这样。// 其实是这样的，比如在2015/12/12/00:00:00最后一次修改文件，对应的过期时间应该是// 2015/12/19/00:00:00，不过现在时间是2015/12/27/00:00:00，我先将当前时间减去1个星期，得到// 2015/12/20/00:00:00，这个时间才是我们函数中的expirationDate。// 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行。NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];// 用来存储对应文件的一些属性，比如文件所需磁盘空间NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];// 记录当前已经使用的磁盘缓存大小NSUInteger currentCacheSize = 0;// 在缓存的目录开始遍历文件. 此次遍历有两个目的://// 1. 移除过期的文件// 2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];for (NSURL *fileURL in fileEnumerator) &#123;NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];// 当前扫描的是目录，就跳过if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;continue;&#125;// 移除过期文件// 这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期，具体解释见上面NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;[urlsToDelete addObject:fileURL];continue;&#125;// 计算当前已经使用的cache大小，// 并将对应file的属性存到cacheFiles中NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];currentCacheSize += [totalAllocatedSize unsignedIntegerValue];[cacheFiles setObject:resourceValues forKey:fileURL];&#125;for (NSURL *fileURL in urlsToDelete) &#123;// 根据需要移除文件的url来移除对应file[_fileManager removeItemAtURL:fileURL error:nil];&#125;// 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件。// 删除策略就是，首先删除修改时间更早的缓存文件if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123;// 直接将当前cache大小降到允许最大的cache大小的一般const NSUInteger desiredCacheSize = self.maxCacheSize / 2;// 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrentusingComparator:^NSComparisonResult(id obj1, id obj2) &#123;return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];&#125;];// 每次删除file后，就计算此时的cache的大小// 如果此时的cache大小已经降到期望的大小了，就停止删除文件了for (NSURL *fileURL in sortedFiles) &#123;if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;// 获取该文件对应的属性NSDictionary *resourceValues = cacheFiles[fileURL];// 根据resourceValues获取该文件所需磁盘空间大小NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];// 计算当前cache大小currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];if (currentCacheSize &lt; desiredCacheSize) &#123;break;&#125;&#125;&#125;&#125;// 如果有completionBlock，就在主线程中调用if (completionBlock) &#123;dispatch_async(dispatch_get_main_queue(), ^&#123;completionBlock();&#125;);&#125;&#125;);&#125; 图片储存路径:1234567891011121314151617181920212223242526272829303132// 简单封装了cachePathForKey:inPath- (NSString *)defaultCachePathForKey:(NSString *)key &#123;return [self cachePathForKey:key inPath:self.diskCachePath];&#125;// cachePathForKey:inPath- (NSString *)cachePathForKey:(NSString *)key inPath:(NSString *)path &#123;// 根据传入的key创建最终要存储时的文件名NSString *filename = [self cachedFileNameForKey:key];// 将存储的文件路径和文件名绑定在一起，作为最终的存储路径return [path stringByAppendingPathComponent:filename];&#125;// cachedFileNameForKey:- (NSString *)cachedFileNameForKey:(NSString *)key &#123;const char *str = [key UTF8String];if (str == NULL) &#123;str = "";&#125;// 使用了MD5进行加密处理// 开辟一个16字节（128位：md5加密出来就是128bit）的空间unsigned char r[CC_MD5_DIGEST_LENGTH];// 官方封装好的加密方法// 把str字符串转换成了32位的16进制数列（这个过程不可逆转） 存储到了r这个空间中CC_MD5(str, (CC_LONG)strlen(str), r);// 最终生成的文件名就是 "md5码"+".文件类型"NSString *filename = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@",r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@""] ? @"" : [NSString stringWithFormat:@".%@", [key pathExtension]]];return filename;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>原理</tag>
        <tag>图片</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发表状态时间和当前时间比较]]></title>
    <url>%2F2015%2F04%2F12%2F%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%97%B6%E9%97%B4%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[看微信朋友圈都有几分钟前，几小时前等：因为有朋友要用到了，特意写了一个以供大家使用 代码很简单，贴出来供参考 里面的日期可以随意换 然后返回你想要的123456789101112131415161718192021222324252627282930313233343536373839- (NSString *)gettime&#123; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSDate *date1 = [dateFormatter dateFromString:@"2016-04-12 14:44:44"]; NSDate *date = [NSDate date]; NSString *curdate=[dateFormatter stringFromDate:date]; NSDate *date2 = [dateFormatter dateFromString:curdate]; NSTimeInterval time=[date2 timeIntervalSinceDate:date1]; NSString *timeStr; if ((int)time &lt; 60) &#123; timeStr= [[NSString alloc] initWithFormat:@"%i秒前",(int)time]; &#125;else if ((int)time &lt; 3600)&#123; timeStr= [[NSString alloc] initWithFormat:@"%i分钟前", (int)time/60]; &#125;else if ((int)time &lt; 3600*24)&#123; timeStr= [[NSString alloc] initWithFormat:@"%i小时前", (int)time/3600]; &#125;else&#123; timeStr= [[NSString alloc] initWithFormat:@"%i天前", (int)time/3600/24]; &#125; return timeStr;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>时间标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置全局要使用的头文件]]></title>
    <url>%2F2015%2F04%2F09%2F%E9%85%8D%E7%BD%AEpch%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首先说一下pch的作用：1.存放一些全局的宏(整个项目中都用得上的宏) 2.用来包含一些全部的头文件(整个项目中都用得上的头文件) 如何在Xcode中添加pch文件：1.创建一个pch文件。 2.然后自定义名字，别忘了打勾 3.创建好后还要配置一下路径，根据图来操作。 修改需要写的路径是“项目名/你配置的pch文件名”，在这里项目名是pch。 4.至此就完成了，然后你可以在中间部分写一些头文件，宏定义，且在其他控制器里不用引用可直接使用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>pch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识小笔记]]></title>
    <url>%2F2015%2F02%2F07%2FiOS%E6%80%BB%E7%BB%93%E6%8A%80%E8%83%BD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不定期更新，虽然很多问题都是很简单的，但我还是想记录下来。 字典数组 -&gt; 模型数组MJExtension12NSMutableArray *arr = [LBMMyMenuModel mj_objectArrayWithKeyValuesArray:self.dataList[indexPath.section][@"menus"]];LBMMyMenuModel *model = arr[indexPath.row]; 改变下方tabbar的某个item的标题1[self.tabBarController.tabBar.items objectAtIndex:2].title = self.userModel.userType == 0 ? @"订单" : @"收益"; 视图部分圆角1234567891011121314UIBezierPath maskPath = [UIBezierPath bezierPathWithRoundedRect:view2.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)];CAShapeLayer maskLayer = [[CAShapeLayer alloc] init];maskLayer.frame = view2.bounds;maskLayer.path = maskPath.CGPath;view2.layer.mask = maskLayer;其中byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight指定了需要成为圆角的角。该参数是UIRectCorner类型的，可选的值有：* UIRectCornerTopLeft* UIRectCornerTopRight* UIRectCornerBottomLeft* UIRectCornerBottomRight* UIRectCornerAllCorners从名字很容易看出来代表的意思，使用“|”来组合就好了。 通知代码步骤a页面1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(tableviewreloadData) name:@"shuaxin" object:nil]; b页面12345[[NSNotificationCenter defaultCenter]postNotificationName:@"shuaxin" object:self];//移除通知- (void)dealloc&#123;[[NSNotificationCenter defaultCenter]removeObserver:self name:@"shuaxin" object:nil];&#125; 隐藏分割线 及cell选择样式 及cell样式123tableView.separatorStyle = UITableViewCellSeparatorStyleNone;cell.selectionStyle = UITableViewCellSelectionStyleNone;cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator; masonry适配三方12345678910make.centerX.mas_offset(0); ／／居中make.top.mas_offset(36); ／／距离上方36make.left.mas_offset(15); ／／距离左边15make.size.mas_offset(CGSizeMake(110, 110));/／自身尺寸make.top.equalTo(self.logoIcon.mas_bottom).offset(30); ／／上部距离上个控件30make.width.mas_offset(290);make.height.mas_offset(40);make.left.mas_equalTo(_leftBtn.mas_right);／／左边紧跟上个view的右边make.top.bottom.mas_equalTo(0); ／／上下距离都是0make.width.mas_equalTo(kWindowW/3); ／／ svn 常用命令进入自己的svn镜像文件夹，如果没有，创建一个svn co svn://10.5.151.43 --username sally --password sallyssecretsvn更新svn updatesvn查看状态svn statussvn 提交svn commit -m &#39;本次提交的内容&#39;换svn的地址svn switch —relocatesmartsvn cornerstone 图形化svn工具 类图工具下载网址 textfield 光标及占位符位置参照网址 左边显示图片很简单下面几行代码搞定（右边显示图片同理）：123UIImageView *passwordImage = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"passwordIcon"]];password.leftView = passwordImage;password.leftViewMode = UITextFieldViewModeAlways; 友情提示：上下两个图片的宽度要保持一致，不然会导致占位符的左边无法对其！ 设置占位符的位置和编辑状态时光标的位置试了很多方法感觉都不好使，最终找到一个方法，自定义一个basicTextField继承自UITextField；然后可以重写下面的几个方法：1234567- (CGRect)borderRectForBounds:(CGRect)bounds;- (CGRect)textRectForBounds:(CGRect)bounds;- (CGRect)placeholderRectForBounds:(CGRect)bounds;- (CGRect)editingRectForBounds:(CGRect)bounds;- (CGRect)clearButtonRectForBounds:(CGRect)bounds;- (CGRect)leftViewRectForBounds:(CGRect)bounds;- (CGRect)rightViewRectForBounds:(CGRect)bounds; 下面是具体的代码实现：12345678910111213141516171819202122232425262728293031#import "basicTextField.h"@implementation basicTextField- (CGRect)leftViewRectForBounds:(CGRect)bounds&#123;CGRect iconRect = [super leftViewRectForBounds:bounds];iconRect.origin.x += 10;return iconRect;&#125;// 重写占位符的x值- (CGRect)placeholderRectForBounds:(CGRect)bounds&#123;CGRect placeholderRect = [super placeholderRectForBounds:bounds];placeholderRect.origin.x += 1;return placeholderRect;&#125;// 重写文字输入时的X值- (CGRect)editingRectForBounds:(CGRect)bounds&#123;CGRect editingRect = [super editingRectForBounds:bounds];editingRect.origin.x += 20;return editingRect;&#125;// 重写文字显示时的X值- (CGRect)textRectForBounds:(CGRect)bounds&#123;CGRect textRect = [super editingRectForBounds:bounds];textRect.origin.x += 20;return textRect;&#125;@end iOS连续返回几个界面12345for (UIViewController *controller in self.navigationController.viewControllers) &#123;if ([controller isKindOfClass:[@“你要返回的控制器类名” class]]) &#123;[self.navigationController popToViewController:controller animated:YES];&#125;&#125; 控制导航栏按钮的间距123UIBarButtonItem *spaceItem=[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];spaceItem.width = 15;//把上面的按钮加到按钮中间。 设置占位符的颜色和字体123textField.placeholder = @"username is in here!";[textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@"_placeholderLabel.font"]; 把2015年3月转换成2015－03123456789NSDateFormatter *df = [[NSDateFormatter alloc] init];//格式化[df setDateFormat:@"yyyy年M月"];[df setLocale:[[NSLocale alloc]initWithLocaleIdentifier:@"zh_CN"]];NSDate *date =[[NSDate alloc] init];date =[df dateFromString:selectedDate];NSDateFormatter* df2 = [[NSDateFormatter alloc]init];[df2 setDateFormat:@"yyyy-MM"];NSString* str1 = [df2 stringFromDate:date];NSLog(@"%@",str1); cocoapods使用cd到项目目录下，创建并编辑podfile文件vim podfile 输入要使用的三方（vim下插入文本是i）123target &apos;项目名称&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 3.1&apos;end 然后保存退出esc切换 :wq 加载pod install --verbose --no-repo-update 支持http12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt; 查看设备UDID 6种方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
